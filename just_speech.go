// package main

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"time"

	"github.com/go-audio/audio"
	"github.com/joho/godotenv"
	witai "github.com/wit-ai/wit-go"
)

type errorResp struct {
	Body  string `json:"body"`
	Error string `json:"error"`
}

type MessageResponse struct {
	ID       string                 `json:"msg_id"`
	Text     string                 `json:"_text"`
	Entities map[string]interface{} `json:"entities"`
}

// NOTE: wit.ai doesn't support stereo sound for now
// (https://wit.ai/docs/http/20160516#post--speech-link)
func oggToMp3(oggFilepath string) (mp3Filepath string, err error) {
	mp3Filepath = fmt.Sprintf("%s.mp3", oggFilepath)

	// $ ffmpeg -i input.ogg -ac 1 output.mp3
	params := []string{"-i", oggFilepath, "-ac", "1", mp3Filepath}
	cmd := exec.Command("ffmpeg", params...)

	if _, err = cmd.CombinedOutput(); err != nil {
		mp3Filepath = ""
	}

	return mp3Filepath, err
}


func main() {
	err := godotenv.Load(".env")

	witAiToken := os.Getenv("WIT_AI_TOKEN")


	// init witAi client
	witAiClient := witai.NewClient(witAiToken)
	fmt.Println(witAiClient.Version) // so go doesn't throw error

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	// curl -XPOST 'https://api.wit.ai/speech' -i -H "Authorization: Bearer DFMDUQWIE74UNGG2SDJ5N5E7EWLDLMKQ" -H "Content-Type: audio/ogg" --data-binary "@hohoho.ogg"

	// f, err := os.Open("hohoho.ogg")
	// if err != nil {
	// 	// handle err
	// }
	// defer f.Close()
	// req, err := http.NewRequest("POST", "https://api.wit.ai/speech", f)
	// if err != nil {
	// 	// handle err
	// }
	// req.Header.Set("Authorization", "Bearer DFMDUQWIE74UNGG2SDJ5N5E7EWLDLMKQ")
	// req.Header.Set("Content-Type", "audio/ogg")

	// resp, err := http.DefaultClient.Do(req)
	// if err != nil {
	// 	// handle err
	// 	fmt.Println(err)
	// }
	// defer resp.Body.Close()
	// var msgResp *MessageResponse
	// decoder := json.NewDecoder(resp.Body)
	// err = decoder.Decode(&msgResp)
	// fmt.Println(msgResp, msgResp.Text)



	
	// // // bypass witgo library since not working properly
	file, err := os.ReadFile("test.mp3")
	if err != nil {
		fmt.Println("can't open file:" ,err)
	}
	body := bytes.NewBuffer(file)
	req, err := http.NewRequest("POST", "https://api.wit.ai/speech?q=", body)
	if err != nil {
		fmt.Println(err)
	}
	
	headerAuth := fmt.Sprintf("Bearer %s", witAiToken)
	headerAccept := fmt.Sprintf("application/vnd.wit.%s+json", "20170307")
	contentType := "audio/mpeg3"
	
	req.Header.Set("Authorization", headerAuth)
	req.Header.Set("Accept", headerAccept)
	req.Header.Set("Content-Type", contentType)

	httpClient := &http.Client{
		Timeout: time.Second * 10,
	}
	resp, err := httpClient.Do(req)
	if err != nil {
		fmt.Println(err)
	}

	if resp.StatusCode >= http.StatusBadRequest {
		defer resp.Body.Close()

		var e *errorResp
		decoder := json.NewDecoder(resp.Body)
		err = decoder.Decode(&e)
		if err != nil {
			fmt.Println(fmt.Errorf("unable to decode error message: %s", err.Error()))
		}

		// Wit.ai errors sometimes have "error", sometimes "body" message
		if len(e.Error) > 0 {
			fmt.Println(fmt.Errorf("unable to make a request. error: %s", e.Error))
		}

		if len(e.Body) > 0 {
			fmt.Println(fmt.Errorf("unable to make a request. error: %s", e.Body))
		}
	}

	bytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	fmt.Println(string(bytes))

	// var msgResp *MessageResponse
	// decoder := json.NewDecoder(resp.Body)
	// err = decoder.Decode(&msgResp)

	// //fmt.Println("owo is: ", gencurl.FromRequest(req))
	// fmt.Println(msgResp, msgResp.Text, err)





	//send to wit AI to parse	
	//file, err := os.Open("test.mp3")
	// file, err := ioutil.ReadFile("test.mp3")
	// reader := bytes.NewReader(file)
	// speech := witai.Speech{File: reader, ContentType: "audio/mpeg3",}
	// msg_request := witai.MessageRequest{ Speech: &speech,}
	// msg, err := witAiClient.Speech(&msg_request)
	// //file.Close()
	// if err != nil {
	// 	fmt.Println("can't send to witAi:", err)
	// }
	// fmt.Println(msg, msg.Text)


}

func newAudioIntBuffer(r io.Reader) (*audio.IntBuffer, error) {
	buf := audio.IntBuffer{
		Format: &audio.Format{
			NumChannels: 1,
			SampleRate:  8000,
		},
	}
	for {
		var sample int16
		err := binary.Read(r, binary.LittleEndian, &sample)
		switch {
		case err == io.EOF:
			return &buf, nil
		case err != nil:
			return nil, err
		}
		buf.Data = append(buf.Data, int(sample))
	}
}